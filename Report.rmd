---
title: "Income, Crime, and Borders in Canton Zurich"
author: "Thilo Holstein, Hans Josef Thalathara"
date: "2026-01-26"
output:
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: '3'
    number_sections: true
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(readr)
library(MASS)
library(dplyr)
library(sf)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)
library(kableExtra)

source("Scripts/Data Preparation.R")
```
  
\newpage

# Introduction

Burglary patterns across Swiss municipalities have long been a subject of practical interest for law enforcement agencies and local communities alike. In the Canton of Basel-Landschaft, anecdotal observations from police practitioners suggest that burglaries tend to cluster in wealthier municipalities located near Switzerland's international borders. The reasoning behind this observation is intuitive: affluent households may present more attractive targets, and proximity to a border could facilitate quick escape across national jurisdictions. If true, this pattern would have direct implications for resource allocation in crime prevention.

However, anecdotal observations -- no matter how consistent -- are not the same as empirical evidence. What appears as a clear pattern in one canton may not hold elsewhere, and apparent correlations can dissolve once confounding factors are accounted for. This analysis takes those observations as a starting point and asks: do they generalise?

Specifically, we examine whether the same relationship between income, border proximity, and burglary rates exists in the Canton of Zurich -- a canton with a different economic structure, geographic configuration, and population density than Basel-Landschaft. By combining burglary statistics, income data, and geographic boundary data at the municipal level, we test these assumptions empirically using both exploratory visualisation and formal count regression models. The goal is not to confirm the Basel-Landschaft narrative, but to evaluate it critically in a new context.

## Research Question

The central question guiding this analysis is:

> *How does income level relate to burglary rates across municipalities in Canton Zurich, and does proximity to the national border act as an independent predictor of crime?*

This question has two dimensions. First, we investigate whether wealthier municipalities systematically experience more burglaries -- a relationship that would suggest property crime follows economic incentives. Second, we test whether geographic proximity to the Swiss national border adds explanatory power beyond income, which would point to spatial or cross-border dynamics as a contributing factor.

## Approach

We analyse open data from Canton Zurich to investigate these questions at the municipal level. By joining income statistics, crime records, and geographic boundary data, we examine whether income predicts burglary rates, whether border proximity adds explanatory power, and how these patterns evolve over time. The analysis proceeds in three stages: data preparation and cleaning, exploratory visualisation to identify patterns and anomalies, and formal count regression modelling to test our hypotheses statistically.

## Hypotheses

Based on the anecdotal observations described above, we formulate three testable hypotheses. These range from the individual effects of income and border proximity to their potential interaction.

**H1 – Income and Burglaries:**
Municipalities with higher median income exhibit higher burglary rates, as wealthier areas may present more attractive targets.

**H2 – National Border Proximity and Burglaries:**
Municipalities located closer to national borders may experience higher burglary rates due to reduced distances to potential escape routes across international boundaries.

**H3 -- Combined Effect:**
Income and border proximity jointly predict burglary rates better than either variable alone.

# Data Sources

Our analysis draws on five publicly available datasets from three different sources, provided in two distinct formats (CSV and GeoPackage). All data were downloaded locally and are included in the project repository.

## Burglary Data

Burglary statistics by municipality and city district for Canton Zurich (2009--2024), published by the Canton of Zurich on the Open Data portal (data.zh.ch). The dataset contains approximately 15,000 records with variables including municipality identifiers, year, offence type, number of offences, population, and burglary rate per 1,000 inhabitants. Format: CSV.

## Income Data

Two separate income datasets were used:

- **Canton level:** Median taxable income by municipality (2009--2022), published by the Statistical Office of Canton Zurich (data.zh.ch). Format: CSV.
- **City district level:** Median taxable income by city district for the city of Zurich (2009--2023), published by the City of Zurich (data.stadt-zuerich.ch). Format: CSV.

The two datasets were joined at different spatial levels to achieve complete income coverage across both municipalities and city districts.

## Geographic Data

- **Municipality boundaries:** GeoPackage of municipal boundaries for Canton Zurich (data.zh.ch), used for spatial visualisation and as join keys for the burglary and income data.
- **City district boundaries:** GeoPackage of Zurich city district boundaries (data.stadt-zuerich.ch), providing geometries for the 12 Stadtkreise.
- **Swiss national borders:** GeoPackage from swisstopo (swissBOUNDARIES3D), used to calculate each municipality's distance to the nearest national border.



# Cleaning and Formatting the Dataset

## Data Formatting

Burglary data for the canton of Zurich were restricted to records representing total burglaries (“Einbrüche insgesamt”), which was the sum across different burglary types. Observations with unknown municipality names or unknown city districts were excluded. Variables related to legal references were removed, as they were not required for the analysis.

Median income data were integrated at two seperate spatial levels. At the municipality level, median income data from Canton Zurich were filtered to exclude cantonal aggregates and the city of Zurich itself. The dataset was reduced to essential variables: municipality identifier, name, year, and income value. At the city district level, median income data for the city of Zurich were filtered to include only the standard tax rate, and converted from thousands to actual values by multiplying the 50th percentile income by 1000.

Spatial boundary data for municipalities in the canton of Zurich were obtained from an official GeoPackage. Only geometries corresponding to municipalities were retained, while non-municipality and city-level geometries were excluded. The dataset was reduced to the municipality identifier and the corresponding geometry.

Swiss national border data were sourced from swisstopo and imported from a GeoPackage file. The data were filtered to retain only the Swiss national boundary. The polygon representation of the national territory was converted into a boundary line to enable distance calculations.

Prior to spatial analysis, all municipality geometries were transformed to a common coordinate reference system matching that of the Swiss border data. For each municipality, the centroid of the polygon geometry was computed. Euclidean distances from these centroids to the Swiss national border line were then calculated. Distances were stored in meters and additionally converted into kilometers for interpretability.

City district geometries for the city of Zurich were processed separately. Because the original dataset contained curved polygon geometries, the data were converted into standard multipolygon geometries using GDAL utilities. The converted geometries were subsequently imported, restricted to district identifiers and geometries, and transformed to the same coordinate reference system as the Swiss border data. Centroids were calculated for each city district, and distances to the Swiss national border were computed analogously to the municipality-level analysis, again expressed in both meters and kilometers.

```{r echo = FALSE, include = FALSE}
## Burglary data canton ZH
ktzh_ebd <- read.csv("Data/KTZH_EBD.csv")

# Remove unnecessary records
ebd <- ktzh_ebd %>% 
  filter(Tatbestand == 'Einbrüche insgesamt', 
         Gemeindename != "unbekannt ZH",
         Stadtkreis_Name != "unbekannt") %>% 
  select(-c(Gesetz_Nummer, Gesetz_Abk))

## Income data on municipality level
income_kt <- read.csv("Data/KTZH_Income_median.csv")

# Remove non-municipality and city data and unused columns
income_kt <- income_kt %>% 
  filter(!BFS_NR %in% c(0, 261)) %>% 
  select(BFS_NR, GEBIET_NAME, INDIKATOR_JAHR, INDIKATOR_VALUE) %>% 
  rename(INCOME_VALUE = INDIKATOR_VALUE)

## Income data on city district level
income_st <- read.csv("Data/STZH_Income_median.csv")

income_st <- income_st %>% 
  filter(SteuerTarifLang == "Grundtarif") %>% 
  select(-c("KreisSort", 
            "KreisCd", 
            "SteuerTarifSort", 
            "SteuerTarifCd",
            "SteuerTarifLang")) %>% 
  mutate(INCOME_VALUE = SteuerEinkommen_p50 * 1000)

# Read .gpkg of municipalities
ktzh_gpkg <- st_read("Data/KTZH_Gemeindegrenzen_OGD.gpkg", 
                             layer = "UP_GEMEINDEN_SEEN_F")

# Remove non-municipality and city geoms
ktzh_geom <- ktzh_gpkg %>% 
  filter(!ktzh_gpkg$BFS %in% c(0, 261), ktzh_gpkg$ART_CODE == 1) %>% 
  select(BFS, geom)

# Read .gpkg of swiss borders (swisstopo)
swiss_borders <- st_read("Data/CH_Borders_swisstopo.gpkg", 
                         layer = "tlm_landesgebiet")

swiss_borders <- swiss_borders %>% 
  filter(swiss_borders$icc == "CH")

# Calculate distance to border
swiss_border_line <- st_boundary(swiss_borders)

# Ensure same CRS
ktzh_geom <- st_transform(ktzh_geom, st_crs(swiss_borders))

# Calculate distance to border
ktzh_geom <- ktzh_geom %>% 
  st_transform(st_crs(swiss_borders)) %>%
  mutate(
    distance_to_border = st_distance(st_centroid(.), swiss_border_line)[,1],
    distance_to_border_km = as.numeric(distance_to_border) / 1000
  ) %>% 
  select(BFS, geom, distance_to_border, distance_to_border_km)

# Convert the city district .gpkg CURVEPOLYGON TO MULTIPOLYGON using gdal_utils
gdal_utils(
  util = "vectortranslate",
  source = "Data/STZH_Stadtkreise_OGD.gpkg",
  destination = "Data/STZH_lin.gpkg",
  options = c("-nlt", "MULTIPOLYGON", 
              "-lco", "GEOMETRY_NAME=geom",
              "-overwrite")
)

# Read the converted file
stzh_gpkg <- st_read("Data/STZH_lin.gpkg")

stzh_geom <- stzh_gpkg %>% 
  select(kname, geom) %>% 
  st_transform(st_crs(swiss_borders)) %>% 
  mutate(
    distance_to_border = st_distance(st_centroid(.), swiss_border_line)[,1],
    distance_to_border_km = as.numeric(distance_to_border) / 1000
  )
```

## Investigating Missing Values

```{r echo = FALSE}
# 1. EBD dataset - check data availability by municipality
ebd_years <- unique(ebd$Ausgangsjahr)
ebd_year_range <- range(ebd_years)

ebd_coverage <- ebd %>%
  group_by(Gemeinde_BFS_Nr, Gemeindename) %>%
  summarise(
    min_year = min(Ausgangsjahr),
    max_year = max(Ausgangsjahr),
    n_years = n_distinct(Ausgangsjahr),
    missing_years = max(ebd_years) - min(ebd_years) + 1 - n_years,
    dataset = "Burglary",
    .groups = 'drop'
  )

incomplete_ebd <- ebd_coverage %>%
  filter(min_year > min(ebd_years) | max_year < max(ebd_years) | missing_years > 0)

# 2. Income_st dataset - check data availability
income_st_years <- unique(income_st$StichtagDatJahr)
income_st_year_range <- range(income_st_years)

income_st_coverage <- income_st %>%
  group_by(KreisLang) %>%
  summarise(
    min_year = min(StichtagDatJahr),
    max_year = max(StichtagDatJahr),
    n_years = n_distinct(StichtagDatJahr),
    missing_years = max(income_st_years) - min(income_st_years) + 1 - n_years,
    dataset = "Income (City Districts)",
    .groups = 'drop'
  ) %>%
  rename(Gemeindename = KreisLang) %>%
  mutate(Gemeinde_BFS_Nr = NA_integer_)

# 3. Income_kt dataset - check data availability
income_kt_years <- unique(income_kt$INDIKATOR_JAHR)
income_kt_year_range <- range(income_kt_years)

income_kt_coverage <- income_kt %>%
  group_by(BFS_NR, GEBIET_NAME) %>%
  summarise(
    min_year = min(INDIKATOR_JAHR),
    max_year = max(INDIKATOR_JAHR),
    n_years = n_distinct(INDIKATOR_JAHR),
    missing_years = max(income_kt_years) - min(income_kt_years) + 1 - n_years,
    dataset = "Income (Canton)",
    .groups = 'drop'
  ) %>%
  rename(Gemeinde_BFS_Nr = BFS_NR, Gemeindename = GEBIET_NAME)

# Combine all coverage data
all_coverage <- bind_rows(
  ebd_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset),
  income_st_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset),
  income_kt_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset)
)

# Simple boxplot with jitter - no annotations
p1 <- ggplot(all_coverage, aes(x = dataset, y = n_years, fill = dataset)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3, size = 1) +
  labs(
    title = "Data Availability Comparison Across Datasets",
    x = "Dataset",
    y = "Number of Years Available",
    fill = "Dataset"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# Display plot
print(p1)
```

The datasets employed in this analysis vary in their temporal completeness across the observation period from 1999 to 2024. Among the three primary data sources, only the income data for city districts (Stadt Zurich) provide complete coverage for all geographic units across the entire timeframe, with no missing observations.
The burglary dataset exhibits minimal missingness, with one municipality showing absent data for reasons that could not be determined from the available documentation. The limited scope of this gap suggests negligible impact on the overall analysis.
Income data at the cantonal level (municipal aggregation) demonstrate more substantial incompleteness, with several municipalities missing data for specific years. Table 1 provides a detailed breakdown of missing observations by municipality and year, allowing for transparent assessment of potential limitations in temporal coverage.

\newpage

```{r echo = FALSE, results = 'asis'}
all_coverage %>%
  filter(missing_years > 0) %>%
  arrange(dataset, n_years) %>%
  select(dataset, Gemeindename, Gemeinde_BFS_Nr, n_years, missing_years, start_year = min_year, end_year = max_year) %>%
  kable(caption = "Municipalities with Incomplete Coverage",
        col.names = c("Dataset", "Municipality", "BFS Nr", "Years Available", 
                      "Missing Years", "Start Year", "End Year"),
        format = "latex",
        longtable = TRUE,
        booktabs = TRUE) %>%
  kable_styling(font_size = 9, latex_options = "scale_down")
```

Further investigation revealed that the missing income data were not random but rather systematic, arising from administrative boundary changes. Between 2015 and 2019, several municipalities in Canton Zurich underwent mergers, resulting in the creation of new administrative units with updated BFS (Federal Statistical Office) identifiers. Specifically:

- On 1 January 2019, the former municipalities of Ober-, Unterstammheim, and Waltalingen merged to form the new municipality of Stammheim - On 1 January 2019, the former municipalities of Hütten and Schönenberg merged into the municipality of Wädenswil  
- On 1 January 2018, the former municipality of Hofstetten merged into the municipality of Elgg  
- On 1 January 2018, the former municipality of Hirzel merged into the municipality of Horgen  
- On 1 January 2016, Kyburg and Illnau-Effretikon merged to form the municipality of Illnau-Effretikon  

These mergers resulted in discontinued BFS identifiers for the former municipalities, with new identifiers assigned to the merged entities. Consequently, income data appeared "missing" for the merged municipalities in pre-merger years, as these records remained associated with the former municipal identifiers.
To address this issue, we implemented a systematic reconciliation procedure. For each merged municipality, we first assessed the completeness of income data under the new identifier. Where gaps existed for pre-merger years, we reconstructed the median income values by averaging data from the constituent former municipalities. This approach ensured temporal continuity in the income variable while maintaining geographic consistency with the current administrative boundaries used in the burglary and spatial datasets.

```{r echo = FALSE, include = FALSE}
# Define merger mapping
merger_mapping <- tribble(
  ~old_BFS_Nr, ~new_BFS_Nr, ~merge_year,
  # Stammheim merger (2019)
  36,          292,          2019,
  42,          292,          2019,
  44,          292,          2019,
  # Wädenswil merger (2019)
  134,         293,          2019,
  140,         293,          2019,
  142,         293,          2019,
  # Elgg merger (2018)
  217,         294,          2018,
  222,         294,          2018,
  # Horgen merger (2018)
  132,         295,          2018,
  133,         295,          2018,
  # Illnau-Effretikon merger (2016)
  174,         296,          2016,
  175,         296,          2016,
  # Bauma merger (2015)
  171,         297,          2015,
  179,         297,          2015
)

all_synthetic <- list()

years <- sort(unique(income_kt$INDIKATOR_JAHR))

for (bfs in unique(merger_mapping$new_BFS_Nr)) {
  
  old_bfs <- merger_mapping %>% 
    filter(new_BFS_Nr == bfs) %>% 
    pull(old_BFS_Nr)
  
  bfs_years <- income_kt %>%
    filter(BFS_NR == bfs) %>%
    pull(INDIKATOR_JAHR) %>%
    unique()
  
  missing_years <- setdiff(years, bfs_years)
  
  if (length(missing_years) > 0) {
    
    synthetic <- income_kt %>% 
      filter(BFS_NR %in% old_bfs,
             INDIKATOR_JAHR %in% missing_years) %>%
      group_by(INDIKATOR_JAHR) %>%
      summarise(
        INCOME_VALUE = mean(INCOME_VALUE, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      mutate(BFS_NR = bfs)
    
    all_synthetic[[as.character(bfs)]] <- synthetic
  }
}

income_old_bfs_all <- bind_rows(all_synthetic) %>%
  left_join(
    income_kt %>%
      select(BFS_NR, GEBIET_NAME) %>%
      distinct(),
    by = "BFS_NR"
  )

# Remove ALL old municipalities
income_kt <- income_kt %>%
  filter(!BFS_NR %in% merger_mapping$old_BFS_Nr)

# Add synthetic rows
income_kt <- income_kt %>%
  bind_rows(income_old_bfs_all) %>%
  arrange(BFS_NR, INDIKATOR_JAHR)
```

After the merger reconciliation and joining all datasets, 329 of 2,735 observations (12.0%) retain missing values in the income variable. These arise from two remaining causes:

- **2023 (158 missing):** Municipal income statistics for Canton Zurich had not yet been published at the time of analysis. Only the 12 city districts of Zurich have income data for this year, sourced from the separate city-level dataset.
- **2024 (171 missing):** No income data are available for any municipality or city district.

All other variables -- burglary counts, population, burglary rates, and border distance -- are complete across the entire observation period. Since the missingness is entirely explained by data availability rather than by any systematic relationship with the outcome variable, the missing-at-random assumption is satisfied.

We retain the full dataset for descriptive and spatial analyses (maps, time series, distributions), where income is not required. For all analyses involving income as a variable -- including the correlation matrix, scatterplots, and regression models -- observations with missing income values are excluded. This approach maximises the use of available data while ensuring that statistical models are estimated on complete cases only.



```{r include = TRUE}
# Merge data sets
data <- ebd %>% 
  left_join(income_kt, 
            by = c("Gemeinde_BFS_Nr" = "BFS_NR",
                   "Ausgangsjahr" = "INDIKATOR_JAHR")) %>% 
  left_join(income_st %>% 
              select(KreisLang, StichtagDatJahr, INCOME_VALUE) %>% 
              rename(INCOME_VALUE_ST = INCOME_VALUE),
            by = c("Stadtkreis_Name" = "KreisLang",
                   "Ausgangsjahr" = "StichtagDatJahr")) %>% 
  mutate(INCOME_VALUE = if_else(!is.na(INCOME_VALUE_ST), 
                                INCOME_VALUE_ST, 
                                INCOME_VALUE)) %>% 
  select(-INCOME_VALUE_ST)

# Join geoms of the municipalities
data <- data %>% 
  left_join(ktzh_geom, by = c("Gemeinde_BFS_Nr" = "BFS"))

# Convert data's geometry to MULTIPOLYGON first
data <- data %>%
  mutate(geom = st_cast(geom, "MULTIPOLYGON"))

# Join and replace only the EMPTY geometries
data <- data %>%
  left_join(
    stzh_geom %>%
      select(kname, 
             geom_stzh = geom, 
             distance_to_border_stzh = distance_to_border, 
             distance_to_border_km_stzh = distance_to_border_km),
    by = c("Stadtkreis_Name" = "kname")
  ) %>%
  mutate(
    geom = if_else(st_is_empty(geom) & !is.na(geom_stzh), 
                   geom_stzh, 
                   geom),
    distance_to_border = coalesce(distance_to_border_stzh, distance_to_border),
    distance_to_border_km = coalesce(distance_to_border_km_stzh, distance_to_border_km)
  ) %>%
  select(-geom_stzh, -distance_to_border_stzh, -distance_to_border_km_stzh) %>%
  st_as_sf() %>% 
  mutate(Gemeinde_BFS_Nr = if_else(Gemeindename == "Zürich", 
                                   Stadtkreis_BFS_Nr, 
                                   Gemeinde_BFS_Nr))
```

# Exploratory Data Analysis

Before testing our hypotheses through formal modelling, we explore the data visually. This section begins with a spatial overview of burglary patterns across the canton, then follows a narrative from the macro level (canton-wide trends over time) down to the micro level (individual municipality patterns), building an increasingly detailed picture of how income, burglaries, and geography interact across Canton Zurich.

## Spatial Overview: Burglary Rates by Municipality

The following maps show the total number of burglaries per municipality, normalised by average population, across the full observation period. This provides a first visual impression of how burglary risk is distributed geographically.

```{r echo = FALSE, fig.show='hold'}
# City outline for map
# Create the outer boundary of Zurich city
city_outline <- data %>%
  filter(!is.na(Stadtkreis_BFS_Nr)) %>%
  st_union()  # Dissolves all districts into one polygon

# Get bounding box of municipalities
bbox <- st_bbox(ktzh_geom)
padding <- 5000  # in map units (meters for Swiss CRS)

# Plot the crime rate across whole data set
ebd_per_gmd <- data %>% 
  group_by(Gemeinde_BFS_Nr) %>% 
  mutate(Total_EBD = sum(Straftaten_total, na.rm = TRUE), 
         Einwohner_avg = mean(Einwohner, na.rm = TRUE),
         EBD_pop_ratio = (Straftaten_total / Einwohner) * 1000) %>% 
  summarise(across(c(geom, Einwohner_avg, Total_EBD, EBD_pop_ratio), first),
  .groups = "drop") %>% 
  st_as_sf()

ggplot() +
  geom_sf(data = swiss_borders, fill = NA, color = "black", linewidth = 1) +
  geom_sf(data = ebd_per_gmd, aes(fill = EBD_pop_ratio), color = "white", linewidth = 0.3) +
  geom_sf(data = city_outline, 
          fill = NA, 
          color = "black", 
          size = 0.5) +
  scale_fill_viridis_c(name = "Burglary Rate (per 1000 Inhabitants)") +
  coord_sf(xlim = c(bbox["xmin"] - padding, bbox["xmax"] + padding), 
           ylim = c(bbox["ymin"] - padding, bbox["ymax"] + padding)) +
  theme_minimal() +
  labs(title = "Number of Burglaries per Municipality by Population")
```

The city district Kreis 1 seems to be a strong outlier in the data. To have a more balanced output of the burglary rate per municipality and population, this is how the map of the canton of Zurich looks without the outlier:

```{r echo = FALSE}
ggplot() +
  geom_sf(data = swiss_borders, fill = NA, color = "black", linewidth = 1) +
  geom_sf(data = ebd_per_gmd %>% filter(Gemeinde_BFS_Nr != 2610001), aes(fill = EBD_pop_ratio), color = "white", linewidth = 0.3) +
  geom_sf(data = city_outline, 
          fill = NA, 
          color = "black", 
          size = 0.5) +
  scale_fill_viridis_c(name = "Burglary Rate (per 1000 Inhabitants)") +
  coord_sf(xlim = c(bbox["xmin"] - padding, bbox["xmax"] + padding), 
           ylim = c(bbox["ymin"] - padding, bbox["ymax"] + padding)) +
  theme_minimal() +
  labs(title = "Number of Burglaries per Municipality by Population (without Kreis 1)")
```

## Descriptive Overview

We begin with a summary of the dataset's structure and the distributions of our key variables. This provides the necessary context for all subsequent analyses.

```{r descriptive-overview, results='asis'}
desc_data <- data %>% st_drop_geometry()

n_obs <- nrow(desc_data)
n_municipalities <- n_distinct(desc_data$Gemeinde_BFS_Nr)
year_range <- range(desc_data$Ausgangsjahr)
n_years <- n_distinct(desc_data$Ausgangsjahr)

cat(paste0(
  "The dataset contains **", format(n_obs, big.mark = "'"), " observations** across **",
  n_municipalities, " municipalities and city districts** over **",
  n_years, " years** (", year_range[1], "–", year_range[2], "). ",
  "Each observation represents one municipality in one year, recording the number of burglaries, ",
  "population size, burglary rate, median income, and distance to the national border.\n"
))
```

```{r summary-table, results='asis'}
summary_stats <- desc_data %>%
  summarise(
    across(
      c(Straftaten_total, Einwohner, Häufigkeitszahl, INCOME_VALUE, distance_to_border_km),
      list(
        mean = ~mean(.x, na.rm = TRUE),
        median = ~median(.x, na.rm = TRUE),
        sd = ~sd(.x, na.rm = TRUE),
        min = ~min(.x, na.rm = TRUE),
        max = ~max(.x, na.rm = TRUE),
        missing = ~sum(is.na(.x))
      ),
      .names = "{.col}__{.fn}"
    )
  ) %>%
  pivot_longer(everything(),
               names_to = c("variable", "stat"),
               names_sep = "__") %>%
  pivot_wider(names_from = stat, values_from = value) %>%
  mutate(variable = recode(variable,
    "Straftaten_total" = "Burglary Count",
    "Einwohner" = "Population",
    "Häufigkeitszahl" = "Burglary Rate (per 1k)",
    "INCOME_VALUE" = "Median Income (CHF)",
    "distance_to_border_km" = "Border Distance (km)"
  ))

knitr::kable(
  summary_stats %>%
    mutate(across(where(is.numeric), ~round(.x, 1))) %>%
    rename(Variable = variable, Mean = mean, Median = median,
           SD = sd, Min = min, Max = max, Missing = missing),
  row.names = FALSE,
  caption = "Summary statistics for key variables"
)
```

The distributions of our key variables reveal important characteristics of the data:

```{r dist-burglary, fig.width=10, fig.height=4}
ggplot(desc_data, aes(x = Straftaten_total)) +
  geom_histogram(bins = 50, fill = "#2c7fb8", alpha = 0.7, color = "white") +
  scale_x_continuous(labels = comma) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Distribution of Burglary Counts",
    subtitle = "Per municipality-year observation",
    x = "Number of Burglaries",
    y = "Frequency"
  )
```

The burglary count distribution is heavily right-skewed: most municipality-year observations record relatively few burglaries, while a small number of large municipalities account for the extreme values. This skew is a hallmark of count data and one reason why standard linear regression is inappropriate here — a point we return to in the modelling section.

```{r dist-income-border, fig.width=10, fig.height=4}
p_income <- ggplot(desc_data %>% filter(!is.na(INCOME_VALUE)),
                   aes(x = INCOME_VALUE)) +
  geom_histogram(bins = 40, fill = "#2c7fb8", alpha = 0.7, color = "white") +
  scale_x_continuous(labels = comma_format(big.mark = "'")) +
  theme_minimal(base_size = 12) +
  labs(title = "Median Income", x = "CHF", y = "Frequency")

p_border <- ggplot(desc_data %>% filter(!is.na(distance_to_border_km)),
                   aes(x = distance_to_border_km)) +
  geom_histogram(bins = 30, fill = "#d95f02", alpha = 0.7, color = "white") +
  theme_minimal(base_size = 12) +
  labs(title = "Distance to Border", x = "km", y = "Frequency")

p_pop <- ggplot(desc_data, aes(x = Einwohner)) +
  geom_histogram(bins = 50, fill = "#4daf4a", alpha = 0.7, color = "white") +
  scale_x_log10(labels = comma) +
  theme_minimal(base_size = 12) +
  labs(title = "Population (log scale)", x = "Inhabitants", y = "Frequency")

gridExtra::grid.arrange(p_income, p_border, p_pop, ncol = 3)
```

Income is approximately normally distributed across municipalities, with most values clustered between 30,000 and 50,000 CHF. Border distance shows a right-skewed distribution — most municipalities lie within 20–30 km of the border, with few exceeding 40 km. Population varies enormously (note the log scale): from small rural communes with fewer than 2,000 residents to Zurich city districts with over 50,000.

```{r correlation-matrix, fig.width=7, fig.height=6}
cor_data <- desc_data %>%
  select(Straftaten_total, Einwohner, Häufigkeitszahl,
         INCOME_VALUE, distance_to_border_km) %>%
  filter(complete.cases(.))

cor_matrix <- cor(cor_data)

# Rename for display
colnames(cor_matrix) <- rownames(cor_matrix) <- c(
  "Burglary\nCount", "Population", "Burglary\nRate",
  "Income", "Border\nDist."
)

# Heatmap
cor_long <- as.data.frame(as.table(cor_matrix)) %>%
  rename(Var1 = Var1, Var2 = Var2, Correlation = Freq)

ggplot(cor_long, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(Correlation, 2)), size = 4) +
  scale_fill_gradient2(low = "#d95f02", mid = "white", high = "#2c7fb8",
                       midpoint = 0, limits = c(-1, 1)) +
  theme_minimal(base_size = 13) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Correlation Matrix of Key Variables",
    x = NULL, y = NULL
  )
```

The correlation matrix provides a first hint at the relationships we will explore in detail. Raw burglary counts correlate strongly with population — unsurprisingly, since larger municipalities have more of everything. This is precisely why we use the burglary *rate* (or count models with a population offset) rather than raw counts in our analysis. The correlations between burglary rate, income, and border distance are the ones relevant to our hypotheses and will be examined in the following sections.

\newpage

## Temporal Trends: Income and Burglary Rates

We begin by examining how burglary rates and median income have evolved across Canton Zurich over time. Since the two variables operate on fundamentally different scales, we normalise both to an index where the first available year equals 100. This allows direct comparison of their relative trajectories.

```{r indexed-timeline, fig.width=10, fig.height=6}
timeline_data <- data %>%
  st_drop_geometry() %>%
  group_by(Ausgangsjahr) %>%
  summarise(
    burglary_rate = mean(Häufigkeitszahl, na.rm = TRUE),
    income = mean(INCOME_VALUE, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(income))

base_year <- min(timeline_data$Ausgangsjahr)
base_vals <- timeline_data %>% filter(Ausgangsjahr == base_year)

timeline_data <- timeline_data %>%
  mutate(
    burglary_index = burglary_rate / base_vals$burglary_rate * 100,
    income_index = income / base_vals$income * 100
  )

timeline_long <- timeline_data %>%
  select(Ausgangsjahr, burglary_index, income_index) %>%
  pivot_longer(cols = c(burglary_index, income_index),
               names_to = "variable",
               values_to = "index") %>%
  mutate(variable = recode(variable,
                           "burglary_index" = "Burglary Rate",
                           "income_index" = "Median Income"))

ggplot(timeline_long, aes(x = Ausgangsjahr, y = index,
                          color = variable, linetype = variable)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "grey50", linewidth = 0.5) +
  scale_color_manual(values = c("Burglary Rate" = "#d95f02",
                                "Median Income" = "#2c7fb8")) +
  scale_x_continuous(breaks = seq(base_year, max(timeline_data$Ausgangsjahr), 1)) +
  theme_minimal(base_size = 13) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Burglary Rate and Median Income Over Time",
    subtitle = paste0("Canton Zurich, indexed (", base_year, " = 100)"),
    x = "Year",
    y = "Index",
    color = NULL,
    linetype = NULL
  )
```

The indexed timeline reveals a striking divergence: while median income has risen steadily over the observation period, burglary rates have declined substantially. This inverse macro-trend already raises questions about the assumed positive relationship in H1. If higher income attracted more burglaries, we would expect both lines to move in the same direction — yet they clearly do not. This motivates a closer look at whether the pattern holds at the municipal level, or whether spatial factors such as border proximity might better explain variation in burglary rates.

\newpage

## Spatial Dimension: Burglary Rates by Border Proximity

The macro-level decline in burglaries may mask important spatial heterogeneity. To investigate whether geography matters, we group municipalities into three categories based on their centroid distance to the Swiss national border and track their burglary rates over time separately.

```{r border-timeline, fig.width=10, fig.height=6}
border_timeline <- data %>%
  st_drop_geometry() %>%
  filter(!is.na(distance_to_border_km), !is.na(Häufigkeitszahl)) %>%
  mutate(border_group = cut(distance_to_border_km,
                            breaks = c(0, 10, 20, Inf),
                            labels = c("< 10 km", "10–20 km", "> 20 km"))) %>%
  group_by(Ausgangsjahr, border_group) %>%
  summarise(
    burglary_rate = mean(Häufigkeitszahl, na.rm = TRUE),
    n_municipalities = n_distinct(Gemeinde_BFS_Nr),
    .groups = "drop"
  )

ggplot(border_timeline, aes(x = Ausgangsjahr, y = burglary_rate,
                            color = border_group)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2.5) +
  scale_color_manual(values = c("< 10 km" = "#e41a1c",
                                "10–20 km" = "#ff7f00",
                                "> 20 km" = "#4daf4a")) +
  scale_x_continuous(breaks = seq(base_year, max(border_timeline$Ausgangsjahr), 1)) +
  theme_minimal(base_size = 13) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Burglary Rate Over Time by Distance to National Border",
    subtitle = "Canton Zurich, municipalities grouped by centroid distance to border",
    x = "Year",
    y = "Burglary Rate (per 1'000 inhabitants)",
    color = "Distance to Border"
  )
```

This chart reveals a clear spatial gradient: municipalities within 10 km of the national border consistently exhibit higher burglary rates than those further inland. While all three groups follow the general downward trend observed in Section 4.1, the gap between border-proximate and interior municipalities persists across the entire observation period. This suggests that border proximity is a structurally relevant factor — not merely a transient pattern — and provides initial support for H2.

\newpage

## Cross-Sectional Analysis: Income vs. Burglary Rate

Having established the temporal and spatial context, we now examine the core relationship hypothesised in H1: does higher municipal income predict higher burglary rates? We aggregate each municipality across all available years and fit a simple linear regression.

```{r h1-scatterplot, fig.width=10, fig.height=7}
h1_data <- data %>%
  st_drop_geometry() %>%
  group_by(Gemeinde_BFS_Nr, Gemeindename) %>%
  summarise(
    income_median = median(INCOME_VALUE, na.rm = TRUE),
    haeufigkeit_mean = mean(Häufigkeitszahl, na.rm = TRUE),
    einwohner_mean = mean(Einwohner, na.rm = TRUE),
    distance_to_border_km = first(distance_to_border_km),
    n_years = n(),
    .groups = "drop"
  ) %>%
  filter(!is.na(income_median), !is.na(haeufigkeit_mean))

lm_h1 <- lm(haeufigkeit_mean ~ income_median, data = h1_data)

r2 <- summary(lm_h1)$r.squared
p_val <- summary(lm_h1)$coefficients[2, 4]
label_text <- paste0("R² = ", round(r2, 3),
                     "\np = ", formatC(p_val, format = "e", digits = 2))

ggplot(h1_data, aes(x = income_median, y = haeufigkeit_mean)) +
  geom_point(aes(size = einwohner_mean), alpha = 0.5, color = "#2c7fb8") +
  geom_smooth(method = "lm", se = TRUE, color = "#d95f02", linewidth = 1) +
  scale_x_continuous(labels = comma_format(big.mark = "'")) +
  scale_size_continuous(name = "Population (avg.)", labels = comma) +
  annotate("text", x = Inf, y = Inf, label = label_text,
           hjust = 1.1, vjust = 1.5, size = 4, fontface = "italic") +
  theme_minimal(base_size = 13) +
  labs(
    title = "H1: Median Income vs. Burglary Rate",
    subtitle = "Per municipality/city district, aggregated across all years",
    x = "Median Income (CHF)",
    y = "Burglary Rate (per 1'000 inhabitants)"
  )
```

The scatterplot does not support H1. The regression line slopes slightly downward, suggesting that wealthier municipalities tend to have marginally lower — not higher — burglary rates. However, the effect is weak: income explains only about 2% of the variance in burglary rates, and the p-value does not reach conventional significance at the 5% level. A few outliers with very high burglary rates (e.g., smaller municipalities like Kreis 1 of Zurich City, where a handful of incidents inflate the rate) are visible in the upper portion of the plot. Given these findings, income alone is a poor predictor of burglary rates. This motivates the inclusion of border proximity as an additional predictor.

\newpage

## Municipality Typology: Income--Crime Clusters

We classify all municipalities into four quadrants based on whether their median income and average burglary rate fall above or below the canton-wide median. This typology provides an intuitive summary of the landscape and highlights which municipalities defy the expected patterns.

```{r cluster-plot, fig.width=10, fig.height=7}
cluster_data <- data %>%
  st_drop_geometry() %>%
  group_by(Gemeinde_BFS_Nr, Gemeindename, Stadtkreis_Name) %>%
  summarise(
    income_median = median(INCOME_VALUE, na.rm = TRUE),
    haeufigkeit_mean = mean(Häufigkeitszahl, na.rm = TRUE),
    einwohner_mean = mean(Einwohner, na.rm = TRUE),
    distance_to_border_km = first(distance_to_border_km),
    .groups = "drop"
  ) %>%
  filter(!is.na(income_median), !is.na(haeufigkeit_mean)) %>%
  mutate(display_name = if_else(Gemeindename == "Zürich",
                                paste0("Zürich - ", Stadtkreis_Name),
                                Gemeindename))

income_threshold <- median(cluster_data$income_median)
crime_threshold <- median(cluster_data$haeufigkeit_mean)

cluster_data <- cluster_data %>%
  mutate(cluster = case_when(
    income_median >= income_threshold & haeufigkeit_mean >= crime_threshold
      ~ "High Income / High Crime",
    income_median >= income_threshold & haeufigkeit_mean < crime_threshold
      ~ "High Income / Low Crime",
    income_median < income_threshold & haeufigkeit_mean >= crime_threshold
      ~ "Low Income / High Crime",
    income_median < income_threshold & haeufigkeit_mean < crime_threshold
      ~ "Low Income / Low Crime"
  ))

ggplot(cluster_data, aes(x = income_median, y = haeufigkeit_mean,
                         color = cluster)) +
  geom_point(aes(size = einwohner_mean), alpha = 0.6) +
  geom_vline(xintercept = income_threshold, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = crime_threshold, linetype = "dashed", color = "grey40") +
  geom_text(data = cluster_data %>%
              filter(haeufigkeit_mean > quantile(haeufigkeit_mean, 0.95) |
                     einwohner_mean > quantile(einwohner_mean, 0.95)),
            aes(label = display_name),
            size = 3, nudge_y = 0.5, show.legend = FALSE) +
  scale_color_manual(values = c(
    "High Income / High Crime" = "#e41a1c",
    "High Income / Low Crime"  = "#4daf4a",
    "Low Income / High Crime"  = "#ff7f00",
    "Low Income / Low Crime"   = "#377eb8"
  )) +
  scale_size_continuous(name = "Population (avg.)", labels = comma) +
  scale_x_continuous(labels = comma_format(big.mark = "'")) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Municipality Clusters: Income vs. Burglary Rate",
    subtitle = "Dashed lines = median thresholds across all municipalities",
    x = "Median Income (CHF)",
    y = "Burglary Rate (per 1'000 inhabitants)",
    color = "Cluster"
  )
```

The quadrant plot reveals that municipalities are distributed relatively evenly across all four clusters, with no strong concentration in the "High Income / High Crime" quadrant that H1 would predict. The labelled outliers — municipalities with exceptionally high burglary rates or large populations — provide concrete cases for further investigation. Notably, the distribution of municipalities across clusters supports the earlier regression findings: income alone does not systematically sort municipalities into high- or low-crime categories. Other factors, particularly geographic location, appear to play a more decisive role.

# Modelling

The exploratory analysis revealed visual patterns -- a spatial gradient near the border and no clear income--crime link -- but visual impressions can be misleading. To rigorously test our three hypotheses, we now turn to formal statistical modelling. We move beyond simple linear regression (which treats burglary *rates* as continuous) and instead model the raw **burglary counts** directly. This is more appropriate because:

- Burglary counts are non-negative integers — classic **count data**.
- Municipalities differ vastly in population size, so we need to account for this.
- The variance in crime counts often exceeds the mean (**overdispersion**), which standard linear models cannot handle.

We fit two types of count regression models — **Poisson** and **Negative Binomial** — and compare their performance.

## Why Count Regression?

A standard linear regression on rates (Häufigkeitszahl) treats every municipality equally, regardless of whether it has 2,000 or 50,000 residents. A municipality with 2 burglaries and 1,000 residents gets the same weight as one with 200 burglaries and 100,000 residents — even though the latter estimate is far more precise. Count regression models solve this by working with the raw counts and using a so-called **offset variable** to account for population size.

### The Offset Variable

The key idea: we model `Straftaten_total` (raw burglary count) as the outcome, but include `log(Einwohner)` as an **offset**. Mathematically:

$$\log(\text{count}) = \beta_0 + \beta_1 \cdot \text{income} + \beta_2 \cdot \text{border distance} + \log(\text{population})$$

Rearranging:

$$\log\left(\frac{\text{count}}{\text{population}}\right) = \beta_0 + \beta_1 \cdot \text{income} + \beta_2 \cdot \text{border distance}$$

So the model effectively predicts the **rate** (burglaries per capita), but it correctly weights each observation by its population size. The offset is not estimated — it enters the model with a fixed coefficient of 1.

### Covariates

We include three covariates (predictor variables):

- **Income** (in 10,000 CHF): Tests whether wealthier municipalities experience more burglaries (H1).
- **Distance to border** (km): Tests whether proximity to the Swiss national border increases burglaries (H2).
- **Year** (centered): Controls for the canton-wide declining trend in burglaries over time.

```{r model-data-prep}
model_data <- data %>%
  st_drop_geometry() %>%
  filter(
    !is.na(Straftaten_total),
    !is.na(INCOME_VALUE),
    !is.na(distance_to_border_km),
    Einwohner > 0
  ) %>%
  mutate(
    log_pop = log(Einwohner),
    income_10k = INCOME_VALUE / 10000,
    year_centered = Ausgangsjahr - min(Ausgangsjahr)
  )
```

## Poisson Regression

The Poisson model is the natural starting point for count data. It assumes that the outcome follows a Poisson distribution, where the mean equals the variance (**equidispersion**).

```{r poisson-models}
poisson_m1 <- glm(
  Straftaten_total ~ income_10k + offset(log_pop),
  family = poisson(link = "log"),
  data = model_data
)

poisson_m2 <- glm(
  Straftaten_total ~ distance_to_border_km + offset(log_pop),
  family = poisson(link = "log"),
  data = model_data
)

poisson_full <- glm(
  Straftaten_total ~ income_10k + distance_to_border_km + year_centered +
    offset(log_pop),
  family = poisson(link = "log"),
  data = model_data
)
```

```{r poisson-results, results='asis'}
s_pois <- summary(poisson_full)
pois_coefs <- s_pois$coefficients

cat("**Poisson Full Model: Burglary Count ~ Income + Border Distance + Year + offset(log Population)**\n\n")

pois_table <- data.frame(
  Variable = c("(Intercept)", "Income (10k CHF)", "Distance to Border (km)", "Year"),
  Estimate = round(pois_coefs[, "Estimate"], 4),
  `Std. Error` = round(pois_coefs[, "Std. Error"], 4),
  `p-value` = formatC(pois_coefs[, "Pr(>|z|)"], format = "e", digits = 2),
  check.names = FALSE
)
knitr::kable(pois_table, row.names = FALSE)
```

Under the Poisson model, all three predictors appear highly significant. However, before interpreting these results, we must verify the model's core assumption — that the variance of burglary counts equals the mean.

### Checking for Overdispersion

The critical Poisson assumption is that the variance equals the mean. We check this with the **dispersion statistic**: the sum of squared Pearson residuals divided by the degrees of freedom. A value near 1 indicates the assumption holds; values much greater than 1 signal **overdispersion**.

```{r overdispersion-check, results='asis'}
pearson_resid <- residuals(poisson_full, type = "pearson")
dispersion <- sum(pearson_resid^2) / poisson_full$df.residual

cat(paste0("**Dispersion statistic: ", round(dispersion, 2), "**\n\n"))

if (dispersion > 2) {
  cat("The dispersion statistic is substantially greater than 1, confirming that the data are **overdispersed**. ")
  cat("This means the Poisson model underestimates the true variability in burglary counts. ")
  cat("Consequently, the standard errors are too small, and the p-values are artificially low — ")
  cat("the model appears more confident in its estimates than it should be. ")
  cat("This motivates fitting a Negative Binomial model, which explicitly accounts for overdispersion.\n")
} else {
  cat("The dispersion statistic is close to 1, suggesting that the Poisson assumption is reasonable.\n")
}
```

## Negative Binomial Regression

The Negative Binomial (NB) model extends the Poisson by adding an extra parameter **theta** ($\theta$) that captures the overdispersion. When $\theta \to \infty$, the NB reduces to the Poisson. When $\theta$ is small, there is substantial extra variability beyond what the Poisson allows.

This extra variability reflects real-world factors not captured by our covariates: differences in local policing, urban vs. rural character, socioeconomic conditions, and other unobserved heterogeneity between municipalities.

```{r nb-models}
nb_m1 <- glm.nb(
  Straftaten_total ~ income_10k + offset(log_pop),
  data = model_data
)

nb_m2 <- glm.nb(
  Straftaten_total ~ distance_to_border_km + offset(log_pop),
  data = model_data
)

nb_m3 <- glm.nb(
  Straftaten_total ~ income_10k + distance_to_border_km + offset(log_pop),
  data = model_data
)

nb_full <- glm.nb(
  Straftaten_total ~ income_10k + distance_to_border_km + year_centered +
    offset(log_pop),
  data = model_data
)

nb_interaction <- glm.nb(
  Straftaten_total ~ income_10k * distance_to_border_km + year_centered +
    offset(log_pop),
  data = model_data
)
```

### NB Model Results

```{r nb-results, results='asis'}
s_nb <- summary(nb_full)
nb_coefs <- s_nb$coefficients

cat("**NB Full Model: Burglary Count ~ Income + Border Distance + Year + offset(log Population)**\n\n")

nb_table <- data.frame(
  Variable = c("(Intercept)", "Income (10k CHF)", "Distance to Border (km)", "Year"),
  Estimate = round(nb_coefs[, "Estimate"], 4),
  `Std. Error` = round(nb_coefs[, "Std. Error"], 4),
  `p-value` = formatC(nb_coefs[, "Pr(>|z|)"], format = "e", digits = 2),
  check.names = FALSE
)
knitr::kable(nb_table, row.names = FALSE)

cat(paste0("\n\n**Theta (overdispersion parameter): ", round(nb_full$theta, 3), "**\n\n"))
```

Compared to the Poisson model, the NB standard errors are noticeably larger and several p-values increase substantially. This is the expected consequence of accounting for overdispersion: the model no longer overstates its confidence. The theta parameter quantifies the degree of extra-Poisson variability — a small theta indicates substantial overdispersion.

### Incidence Rate Ratios

The exponentiated coefficients give **Incidence Rate Ratios (IRR)**. An IRR of 0.95 for border distance means: each additional kilometre away from the border *multiplies* the expected burglary rate by 0.95 — i.e., a 5% decrease per kilometre.

```{r irr-table, results='asis'}
irr <- exp(coef(nb_full))
irr_ci <- exp(confint(nb_full))
irr_table <- data.frame(
  Variable = c("(Intercept)", "Income (10k CHF)", "Distance to Border (km)", "Year"),
  IRR = round(irr, 4),
  `CI lower (2.5%)` = round(irr_ci[, 1], 4),
  `CI upper (97.5%)` = round(irr_ci[, 2], 4),
  check.names = FALSE
)
knitr::kable(irr_table, row.names = FALSE)
```

The IRR table translates the model coefficients into a more intuitive scale. An IRR close to 1 indicates no meaningful effect. The confidence interval for border distance spans 1, reinforcing that it is not a reliable predictor. Income, by contrast, has an IRR and confidence interval entirely below 1 (CI: `r round(irr_ci["income_10k", 1], 3)`–`r round(irr_ci["income_10k", 2], 3)`), confirming a significant protective association. The year variable similarly has an IRR consistently below 1, confirming the steady annual decline in burglary rates.

### Interaction Model: Does Income Matter More Near the Border?

To test H3, we add an interaction term between income and border distance. If the interaction is significant, it would mean that the effect of income on burglaries *depends* on how close a municipality is to the border.

```{r interaction-results, results='asis'}
s_int <- summary(nb_interaction)
int_coefs <- s_int$coefficients

int_table <- data.frame(
  Variable = c("(Intercept)", "Income (10k CHF)", "Distance to Border (km)",
               "Year", "Income x Border Distance"),
  Estimate = round(int_coefs[, "Estimate"], 4),
  `Std. Error` = round(int_coefs[, "Std. Error"], 4),
  `p-value` = formatC(int_coefs[, "Pr(>|z|)"], format = "e", digits = 2),
  check.names = FALSE
)
knitr::kable(int_table, row.names = FALSE)
```

The interaction term (Income × Border Distance) is statistically significant (p = `r formatC(int_coefs["income_10k:distance_to_border_km", "Pr(>|z|)"], format = "e", digits = 2)`), and notably, including it renders both main effects significant as well — a pattern that was absent in the additive NB model. This suggests that the relationship between income and burglary rates is modulated by geographic proximity to the border.

However, interpreting this result requires caution. The significant interaction indicates a statistical dependency between income and border distance, but the practical relevance is limited. The positive interaction coefficient (+`r round(int_coefs["income_10k:distance_to_border_km", "Estimate"], 4)`) implies that the negative income effect weakens as distance to the border increases — in other words, the protective association of higher income diminishes further from the border. Yet the AIC improvement over the additive NB model is marginal (`r round(AIC(nb_interaction), 1)` vs. `r round(AIC(nb_full), 1)`), suggesting that the interaction, while statistically detectable, adds only modest explanatory power. Given the large sample size (n = `r format(nobs(nb_interaction), big.mark = ",")` complete observations), even small effects can reach significance without being substantively meaningful. We therefore interpret H3 with caution: there is evidence of a statistical interaction, but it does not substantially improve prediction of burglary rates.

## Model Comparison: Poisson vs. Negative Binomial

Having fitted both model families, we now systematically compare them to determine which provides the more reliable basis for inference. This comparison proceeds through four complementary lenses: a formal statistical test, an information criterion, a visual comparison of coefficient uncertainty, and diagnostic checks of the residuals.

### Likelihood Ratio Test

Since the Poisson model is nested within the NB (the Poisson is a special case when $\theta \to \infty$), we can use a **likelihood ratio test** to determine whether the extra parameter $\theta$ significantly improves the fit.

```{r lr-test, results='asis'}
lr_stat <- 2 * (logLik(nb_full) - logLik(poisson_full))
lr_pval <- pchisq(as.numeric(lr_stat), df = 1, lower.tail = FALSE)

cat(paste0("- **LR statistic:** ", round(as.numeric(lr_stat), 2), "\n"))
cat(paste0("- **p-value:** ", formatC(lr_pval, format = "e", digits = 3), "\n\n"))

if (lr_pval < 0.05) {
  cat("The test is highly significant: the NB model fits substantially better than the Poisson. ")
  cat("This confirms that overdispersion is present and must be accounted for.\n")
} else {
  cat("The test is not significant: the Poisson model is adequate.\n")
}
```

### AIC Comparison

```{r aic-comparison, results='asis'}
aic_table <- data.frame(
  Model = c("Poisson (full)", "Negative Binomial (full)", "NB with interaction"),
  AIC = round(c(AIC(poisson_full), AIC(nb_full), AIC(nb_interaction)), 1),
  `Log-Likelihood` = round(c(as.numeric(logLik(poisson_full)),
                              as.numeric(logLik(nb_full)),
                              as.numeric(logLik(nb_interaction))), 1),
  check.names = FALSE
)
knitr::kable(aic_table, row.names = FALSE)

cat("\n*Lower AIC indicates better fit, penalised for model complexity.*\n")
```

### Coefficient Comparison

A key consequence of overdispersion: the Poisson model produces **artificially small standard errors**, making predictors appear more significant than they truly are. The NB model provides more honest uncertainty estimates.

```{r coef-comparison, results='asis', fig.width=10, fig.height=5}
vars <- c("income_10k", "distance_to_border_km", "year_centered")
var_labels <- c("Income (10k CHF)", "Distance to Border (km)", "Year")

comp_data <- data.frame(
  Variable = rep(var_labels, 2),
  Model = rep(c("Poisson", "Negative Binomial"), each = 3),
  Estimate = c(pois_coefs[vars, "Estimate"], nb_coefs[vars, "Estimate"]),
  SE = c(pois_coefs[vars, "Std. Error"], nb_coefs[vars, "Std. Error"])
)

ggplot(comp_data, aes(x = Variable, y = Estimate, color = Model)) +
  geom_point(position = position_dodge(width = 0.5), size = 3) +
  geom_errorbar(aes(ymin = Estimate - 1.96 * SE, ymax = Estimate + 1.96 * SE),
                position = position_dodge(width = 0.5), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  scale_color_manual(values = c("Poisson" = "#d95f02", "Negative Binomial" = "#2c7fb8")) +
  coord_flip() +
  theme_minimal(base_size = 13) +
  labs(
    title = "Coefficient Estimates: Poisson vs. Negative Binomial",
    subtitle = "Error bars = 95% confidence intervals",
    x = NULL,
    y = "Coefficient Estimate",
    color = NULL
  )
```

The coefficient estimates are broadly similar between both models for income and year, but the NB confidence intervals are substantially wider — reflecting the true uncertainty in the data. The most striking difference concerns border distance: in the Poisson model, the coefficient is negative and highly significant (β = −0.007, p ≈ 0), suggesting that municipalities closer to the border experience higher burglary rates. In the Negative Binomial model, the coefficient flips sign (β = +`r round(nb_coefs["distance_to_border_km", "Estimate"], 3)`) and becomes non-significant (p = `r round(nb_coefs["distance_to_border_km", "Pr(>|z|)"], 2)`). This reversal is a direct consequence of accounting for overdispersion: the Poisson model's artificially narrow standard errors produced a spurious result that dissolves under more appropriate modelling assumptions. This finding serves as a cautionary example — had we relied solely on the Poisson model, we would have drawn the opposite conclusion regarding border proximity.

Any predictor that remains significant under both models — in this case, income and year — can be considered robustly supported.

### Observed vs. Predicted

```{r obs-vs-pred, fig.width=10, fig.height=5}
model_data <- model_data %>%
  mutate(
    pred_poisson = predict(poisson_full, type = "response"),
    pred_nb = predict(nb_full, type = "response")
  )

pred_long <- model_data %>%
  select(Straftaten_total, pred_poisson, pred_nb) %>%
  pivot_longer(cols = c(pred_poisson, pred_nb),
               names_to = "model",
               values_to = "predicted") %>%
  mutate(model = recode(model,
                        "pred_poisson" = "Poisson",
                        "pred_nb" = "Negative Binomial"))

ggplot(pred_long, aes(x = predicted, y = Straftaten_total, color = model)) +
  geom_point(alpha = 0.3, size = 1.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey40") +
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(~ model) +
  scale_color_manual(values = c("Poisson" = "#d95f02", "Negative Binomial" = "#2c7fb8")) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Observed vs. Predicted Burglary Counts",
    subtitle = "Dashed line = perfect prediction (log-log scale)",
    x = "Predicted Count",
    y = "Observed Count"
  ) +
  theme(legend.position = "none")
```

If the models predicted perfectly, all points would fall on the diagonal dashed line. Both models show a similar pattern: predictions cluster along the diagonal for moderate counts, but diverge for very small and very large values. This is expected — municipalities with extreme burglary counts (either very few or very many) are inherently harder to predict with only three covariates. The key observation is that both models produce comparable predictions; the advantage of the NB lies not in better point predictions, but in more honest uncertainty estimates.

### Residual Diagnostics

```{r residual-diagnostics, fig.width=10, fig.height=5}
model_data <- model_data %>%
  mutate(
    resid_poisson = residuals(poisson_full, type = "pearson"),
    resid_nb = residuals(nb_full, type = "pearson")
  )

resid_long <- model_data %>%
  select(resid_poisson, resid_nb) %>%
  pivot_longer(everything(),
               names_to = "model",
               values_to = "residual") %>%
  mutate(model = recode(model,
                        "resid_poisson" = "Poisson",
                        "resid_nb" = "Negative Binomial"))

ggplot(resid_long, aes(x = residual)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#2c7fb8", alpha = 0.7) +
  stat_function(fun = dnorm, color = "#d95f02", linewidth = 1) +
  facet_wrap(~ model, scales = "free_x") +
  coord_cartesian(xlim = c(-5, 15)) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Distribution of Pearson Residuals",
    subtitle = "Orange curve = standard normal (expected for a well-fitting model)",
    x = "Pearson Residual",
    y = "Density"
  )
```

```{r residual-summary, results='asis'}
cat("| Model | Mean | SD |\n")
cat("|-------|------|----|\n")
cat(paste0("| Poisson | ", round(mean(model_data$resid_poisson), 3),
           " | ", round(sd(model_data$resid_poisson), 3), " |\n"))
cat(paste0("| Negative Binomial | ", round(mean(model_data$resid_nb), 3),
           " | ", round(sd(model_data$resid_nb), 3), " |\n"))
cat("\n*For a well-fitting model: mean ≈ 0, SD ≈ 1.*\n")
```

The residual distributions confirm the earlier findings. The Poisson residuals have a standard deviation far exceeding 1, indicating systematic underfitting of the variance — a direct consequence of the equidispersion assumption being violated. The NB residuals are much closer to the expected standard normal shape, with a standard deviation nearer to 1, indicating that the extra theta parameter successfully absorbs the excess variability.

Across all comparison criteria -- the likelihood ratio test, AIC, coefficient uncertainty, and residual diagnostics -- the Negative Binomial model consistently outperforms the Poisson. The Poisson model's assumption of equidispersion is clearly violated, leading to artificially narrow confidence intervals and overly optimistic p-values. We therefore adopt the **Negative Binomial full model** as our primary model for all subsequent hypothesis tests.

## Hypothesis Assessment

With the Negative Binomial model established as the appropriate framework, we now formally evaluate each of our three hypotheses based on its coefficient estimates and significance levels.

**H1 — Income and Burglaries: Not supported (direction reversed):** The NB model yields a statistically significant effect of income (p = `r formatC(nb_coefs["income_10k", "Pr(>|z|)"], format = "e", digits = 2)`), but in the opposite direction to what H1 predicted. Wealthier municipalities show lower, not higher, burglary rates (IRR = `r round(exp(nb_coefs["income_10k", "Estimate"]), 2)` per 10,000 CHF). The "wealthy municipalities attract burglars" hypothesis is thus contradicted by the data — income, if anything, has a protective association.

**H2 — Border Proximity and Burglaries: Not supported:** In the NB model, distance to the national border is not statistically significant (p = `r round(nb_coefs["distance_to_border_km", "Pr(>|z|)"], 2)`). While the exploratory analysis revealed a visually compelling spatial gradient, this pattern does not survive formal modelling once overdispersion is accounted for. The Poisson model had found a significant effect, but as demonstrated in Section 5.4.3, this was an artefact of artificially narrow standard errors. H2 is not supported.

**H3 — Combined Effect: Partially supported (statistically significant, practically limited):** The interaction between income and border distance is statistically significant (p = `r formatC(int_coefs["income_10k:distance_to_border_km", "Pr(>|z|)"], format = "e", digits = 2)`), indicating that the effect of income on burglaries depends on border proximity. However, the AIC improvement over the additive model is marginal, and the interaction does not substantially increase the model's predictive power. Given the large sample size, statistical significance alone does not imply practical importance. We therefore characterise H3 as partially supported: there is evidence of a statistical interaction, but it does not meaningfully improve our ability to predict burglary rates.

# Chapter of Choice

## Interactive Web Application with Shiny

As the Chapter of Choice, we developed an interactive web application using the `shiny` package — a framework for building browser-based applications directly from R, without requiring any knowledge of web development. The application serves as a companion to this report, but with a deliberately different emphasis: where the report focuses on a cross-sectional statistical analysis, the application prioritises **interactivity, geographic exploration, and the development of key variables over time**.

### Motivation

The datasets used in this analysis are well-suited to longitudinal exploration. Burglary data spans 2009 to 2024, income data reaches back to 1999, and all variables are available at a fine spatial resolution — individual municipalities and, for the city of Zurich, individual city districts. A static report cannot fully capture this temporal richness. An interactive application allows the reader to explore patterns at their own pace, select specific locations, and observe how income and burglary rates have evolved over 15 years.

### Structure

The application consists of two main tabs:

**Map** — A choropleth map of Canton Zurich rendered with the `leaflet` package. The user can select any of four variables (median income, population, total burglaries, or burglary rate per 1,000 inhabitants), choose a year via a slider, and optionally exclude known outliers. Polygons are coloured using a continuous viridis palette, and hovering over a municipality displays the exact value. The map updates dynamically without reloading the page.

**Data Explorer** — A municipality- and district-level panel showing four time-series plots side by side: population, median income, burglary trends (broken down by type), and burglary rate per 1,000 inhabitants. All locations in the canton are accessible via a dropdown. For municipalities that underwent administrative mergers between 2015 and 2019, the income plot additionally visualises the pre-merger constituent municipalities, making the data continuity transparent to the user.

[Link to shiny webapp](https://elenoar12-rbootcamp-holstein-thalathara.share.connect.posit.cloud/)

# Conclusions

## Key Findings

This analysis set out to test whether anecdotal observations from Basel-Landschaft -- that burglaries concentrate in wealthier, border-proximate municipalities -- hold in the Canton of Zurich. The results paint a more nuanced picture than expected.

**Income is associated with lower burglary rates, contradicting H1.** Contrary to the intuition that affluent households attract property crime, the Negative Binomial regression shows a significant negative relationship between median income and burglary rates (IRR = `r round(exp(nb_coefs["income_10k", "Estimate"]), 2)` per 10,000 CHF, p < 0.001). The exploratory scatterplot already foreshadowed this result, with an R² of just 0.02 and a slightly downward-sloping regression line. Wealthier municipalities in Canton Zurich do not experience systematically higher burglary rates — if anything, the opposite is true.

**Border proximity is not a reliable predictor of burglary rates (H2 not supported).** The exploratory analysis revealed a visually striking spatial gradient: municipalities within 10 km of the national border consistently showed higher burglary rates than those further inland. However, this pattern does not survive formal modelling. In the Negative Binomial regression, border distance is not statistically significant (p = `r round(nb_coefs["distance_to_border_km", "Pr(>|z|)"], 2)`). Notably, the Poisson model did find a significant effect for border distance, but this result reversed sign and lost significance once overdispersion was properly accounted for — illustrating how model misspecification can produce misleading conclusions. The visual border gradient observed in the EDA may be confounded with other spatial factors such as urbanisation, transport connectivity, or policing intensity, none of which are included in the model.

**The interaction of income and border proximity is statistically detectable but practically limited (H3 partially supported).** The interaction model yields a significant interaction term (p = `r formatC(int_coefs["income_10k:distance_to_border_km", "Pr(>|z|)"], format = "e", digits = 2)`), suggesting that the income–burglary relationship varies with border proximity. However, the improvement in model fit over the additive NB model is marginal (ΔAIC = `r round(AIC(nb_full) - AIC(nb_interaction), 1)`), and the large sample size means that even small effects can reach statistical significance. We therefore characterise this as a partial finding: there is evidence of an interaction, but it does not substantially improve prediction.

**Burglary rates have declined substantially over time.** The year variable is the strongest and most robust predictor across all models. Burglary rates have fallen markedly since 2009 across all municipalities and all border distance categories, likely reflecting broader factors such as improved security technology, changes in policing strategies, or shifts in criminal behaviour. This temporal decline is the clearest and most consistent finding of the analysis.

## Limitations

Several limitations should be considered when interpreting these results.

**Ecological fallacy.** All analyses operate at the municipal level. Even where visual patterns suggest spatial gradients (e.g., higher burglary rates near the border), we cannot draw conclusions about individual-level behaviour from aggregate data.

**Limited model explanatory power.** While the Negative Binomial model is statistically appropriate for the data, the included covariates — income, border distance, and year — explain only a modest share of the variation in burglary counts. A formal goodness-of-fit measure such as McFadden's pseudo-R² would likely confirm that much of the municipality-level variation remains unexplained. This is consistent with the observation that important predictors are missing from the model.

**Omitted variables.** Neither income nor border distance proved to be robust predictors in the formal model, yet the exploratory analysis showed clear visual patterns. This suggests that important explanatory variables — such as urbanisation, transport connectivity, policing intensity, or local socioeconomic structure — are missing from the model and may confound the observed spatial patterns.

**Centroid distance as a proxy.** Border distance is measured from each municipality's geographic centroid to the nearest national border. This is a simplification — municipalities with irregular shapes or large areas may have actual border distances that differ substantially from the centroid measure. A more granular measure (e.g., minimum distance from any point within the municipality boundary) might yield different results.

**Incomplete income data.** Income data are unavailable for 2023–2024 and for four municipalities prior to 2015, limiting the temporal scope of income-related analyses to 2009–2022. While the missingness mechanism is well understood and documented in Section 3.2, it means our models cannot capture the most recent developments.

**Single canton.** The analysis is restricted to Canton Zurich. The patterns observed here may not generalise to other cantons, particularly those with different border configurations (e.g., Basel-Landschaft, Geneva, or Ticino) or different economic structures.

# Generative AI Reflection

AI proved to be a powerful tool that definitely supported us in crafting this project. While it was important to us to understand the concepts of R and exciting to dive into the statistics and explore what stories the data could tell, we used available tools such as ChatGPT and Claude to debug code, improve syntax and writing, and broaden our understanding of what we might research with the given data. In all cases, we tried to validate outputs against course materials rather than accepting them uncritically.

That said, especially agentic AI left us stunned by the potential and automation it brings. Watching an agent autonomously iterate on code, diagnose issues, and propose fixes was both impressive and unsettling. The temptation to delegate entire analytical steps was real, and resisting it required conscious effort — we deliberately wrote core model specifications, data joins, and visualisations ourselves, using AI only to accelerate where we were already confident in the direction.

This leaves us with a broader reflection. AI, and especially the upcoming agents, have the potential to change the way we work in a lasting manner. But even as we develop tools that make it easy to outsource tasks, we shouldn't forget that every step builds on the one before it — and that we, whether as a society or individually, need to keep investing in our own progress and our desire to learn. The Applied Information and Data Science programme definitely sits at a useful intersection here: building the foundation needed to understand how AI tools actually work, while learning to apply them effectively, feels increasingly valuable. Finally, the question shouldn't only be what we'll occupy ourselves with, but how we find a way to coexist with algorithms and machines in this disruptive age — following our curiosity and ultimately not losing the spark that brought us here in the first place.





