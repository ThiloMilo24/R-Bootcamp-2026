---
title: Income and Proximity to National Border's Influence on Burglary Rate in the
  Canton Zurich
author: "Holstein Thilo & Thalathara Hans"
date: "2026-01-26"
output:
  pdf_document:
    toc: true
    toc_depth: '3'
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(readr)
library(dplyr)
library(sf)
library(ggplot2)
library(knitr)
library(kableExtra)
```

# Introduction

Burglary patterns across Swiss municipalities have long been a subject of practical interest for law enforcement agencies. Anecdotal observations from the Canton of Basel-Landschaft suggest that burglaries may occur more frequently in wealthier municipalities, particularly those situated closer to Switzerland's international borders. While such observations are valuable for informing local police work, they raise broader questions about whether similar patterns exist elsewhere and what factors might explain them.
This analysis examines whether these observed trends hold in the Canton of Zurich by investigating the relationship between municipal burglary rates and two key variables: household income levels and proximity to national borders. Rather than assuming that Basel-Landschaft's patterns are universally applicable, we approach this as an empirical question and testing whether income and border proximity are associated with burglary rates in a different cantonal context. By doing so, we aim to move beyond localized observations toward a more systematic understanding of the spatial and socioeconomic factors that may influence property crime across Swiss municipalities.

## Research Question

How does income level and the proximity to the national borders relate to crime rate (burglaries) across municipalities in Canton Zurich?

## Approach

We analyse open data from Canton Zurich to investigate a triangular relationship between income, proximity to Switzerland's national borders, and burglaries at the municipal level. By joining multiple datasets, we examine whether income predicts crime independently, and whether crime and border proximity share a connection beyond what income alone explains.

## Hypotheses

**H1 – Income and Burglaries:**
Municipalities with higher median income exhibit higher burglary rates, as wealthier areas may present more attractive targets.

**H2 – National Border Proximity and Burglaries:**
Municipalities located closer to national borders may experience higher burglary rates due to reduced distances to potential escape routes across international boundaries.

# Data Sources

## Income Data

Median taxable income by municipality (Canton Zurich). Available data from 1999 to 2022.  
https://opendata.swiss/de/dataset/steuerb-einkommen-naturl-pers-median-fr

Median taxable income by district of the city of Zurich. Available data from 1999 to 2023.  
https://www.zh.ch/de/politik-staat/statistik-daten/datenkatalog.html#/datasets/246@statistisches-amt-kanton-zuerich

## Burglary Data

Burglary statistics by municipality (Canton Zurich). Available data from 2009 to 2024.  
https://opendata.swiss/de/dataset/anzahl-einbruche-nach-gemeinden-des-kantons-zurich

## Additional Data

Geopackages of Swiss national borders, municipalities of the canton of Zurich and city districts of the city of Zurich.

# Cleaning and Formatting the Dataset

## Data Formatting

Burglary data for the canton of Zurich were restricted to records representing total burglaries (“Einbrüche insgesamt”), which was the sum across different burglary types. Observations with unknown municipality names or unknown city districts were excluded. Variables related to legal references were removed, as they were not required for the analysis.

Median income data were integrated at two seperate spatial levels. At the municipality level, median income data from Canton Zurich were filtered to exclude cantonal aggregates and the city of Zurich itself. The dataset was reduced to essential variables: municipality identifier, name, year, and income value. At the city district level, median income data for the city of Zurich were filtered to include only the standard tax rate, and converted from thousands to actual values by multiplying the 50th percentile income by 1000.

Spatial boundary data for municipalities in the canton of Zurich were obtained from an official GeoPackage. Only geometries corresponding to municipalities were retained, while non-municipality and city-level geometries were excluded. The dataset was reduced to the municipality identifier and the corresponding geometry.

Swiss national border data were sourced from swisstopo and imported from a GeoPackage file. The data were filtered to retain only the Swiss national boundary. The polygon representation of the national territory was converted into a boundary line to enable distance calculations.

Prior to spatial analysis, all municipality geometries were transformed to a common coordinate reference system matching that of the Swiss border data. For each municipality, the centroid of the polygon geometry was computed. Euclidean distances from these centroids to the Swiss national border line were then calculated. Distances were stored in meters and additionally converted into kilometers for interpretability.

City district geometries for the city of Zurich were processed separately. Because the original dataset contained curved polygon geometries, the data were converted into standard multipolygon geometries using GDAL utilities. The converted geometries were subsequently imported, restricted to district identifiers and geometries, and transformed to the same coordinate reference system as the Swiss border data. Centroids were calculated for each city district, and distances to the Swiss national border were computed analogously to the municipality-level analysis, again expressed in both meters and kilometers.

```{r echo = FALSE, include = FALSE}
## Burglary data canton ZH
ktzh_ebd <- read.csv("Data/KTZH_EBD.csv")

# Remove unnecessary records
ebd <- ktzh_ebd %>% 
  filter(Tatbestand == 'Einbrüche insgesamt', 
         Gemeindename != "unbekannt ZH",
         Stadtkreis_Name != "unbekannt") %>% 
  select(-c(Gesetz_Nummer, Gesetz_Abk))

## Income data on municipality level
income_kt <- read.csv("Data/KTZH_Income_median.csv")

# Remove non-municipality and city data and unused columns
income_kt <- income_kt %>% 
  filter(!BFS_NR %in% c(0, 261)) %>% 
  select(BFS_NR, GEBIET_NAME, INDIKATOR_JAHR, INDIKATOR_VALUE) %>% 
  rename(INCOME_VALUE = INDIKATOR_VALUE)

## Income data on city district level
income_st <- read.csv("Data/STZH_Income_median.csv")

income_st <- income_st %>% 
  filter(SteuerTarifLang == "Grundtarif") %>% 
  select(-c("KreisSort", 
            "KreisCd", 
            "SteuerTarifSort", 
            "SteuerTarifCd",
            "SteuerTarifLang")) %>% 
  mutate(INCOME_VALUE = SteuerEinkommen_p50 * 1000)

# Read .gpkg of municipalities
ktzh_gpkg <- st_read("Data/KTZH_Gemeindegrenzen_OGD.gpkg", 
                             layer = "UP_GEMEINDEN_SEEN_F")

# Remove non-municipality and city geoms
ktzh_geom <- ktzh_gpkg %>% 
  filter(!ktzh_gpkg$BFS %in% c(0, 261), ktzh_gpkg$ART_CODE == 1) %>% 
  select(BFS, geom)

# Read .gpkg of swiss borders (swisstopo)
swiss_borders <- st_read("Data/CH_Borders_swisstopo.gpkg", 
                         layer = "tlm_landesgebiet")

swiss_borders <- swiss_borders %>% 
  filter(swiss_borders$icc == "CH")

# Calculate distance to border
swiss_border_line <- st_boundary(swiss_borders)

# Ensure same CRS
ktzh_geom <- st_transform(ktzh_geom, st_crs(swiss_borders))

# Calculate distance to border
ktzh_geom <- ktzh_geom %>% 
  st_transform(st_crs(swiss_borders)) %>%
  mutate(
    distance_to_border = st_distance(st_centroid(.), swiss_border_line)[,1],
    distance_to_border_km = as.numeric(distance_to_border) / 1000
  ) %>% 
  select(BFS, geom, distance_to_border, distance_to_border_km)

# Convert the city district .gpkg CURVEPOLYGON TO MULTIPOLYGON using gdal_utils
gdal_utils(
  util = "vectortranslate",
  source = "Data/STZH_Stadtkreise_OGD.gpkg",
  destination = "Data/STZH_lin.gpkg",
  options = c("-nlt", "MULTIPOLYGON", 
              "-lco", "GEOMETRY_NAME=geom",
              "-overwrite")
)

# Read the converted file
stzh_gpkg <- st_read("Data/STZH_lin.gpkg")

stzh_geom <- stzh_gpkg %>% 
  select(kname, geom) %>% 
  st_transform(st_crs(swiss_borders)) %>% 
  mutate(
    distance_to_border = st_distance(st_centroid(.), swiss_border_line)[,1],
    distance_to_border_km = as.numeric(distance_to_border) / 1000
  )
```

## Investigating Missing Values

```{r echo = FALSE}
# 1. EBD dataset - check data availability by municipality
ebd_years <- unique(ebd$Ausgangsjahr)
ebd_year_range <- range(ebd_years)

ebd_coverage <- ebd %>%
  group_by(Gemeinde_BFS_Nr, Gemeindename) %>%
  summarise(
    min_year = min(Ausgangsjahr),
    max_year = max(Ausgangsjahr),
    n_years = n_distinct(Ausgangsjahr),
    missing_years = max(ebd_years) - min(ebd_years) + 1 - n_years,
    dataset = "Burglary",
    .groups = 'drop'
  )

incomplete_ebd <- ebd_coverage %>%
  filter(min_year > min(ebd_years) | max_year < max(ebd_years) | missing_years > 0)

# 2. Income_st dataset - check data availability
income_st_years <- unique(income_st$StichtagDatJahr)
income_st_year_range <- range(income_st_years)

income_st_coverage <- income_st %>%
  group_by(KreisLang) %>%
  summarise(
    min_year = min(StichtagDatJahr),
    max_year = max(StichtagDatJahr),
    n_years = n_distinct(StichtagDatJahr),
    missing_years = max(income_st_years) - min(income_st_years) + 1 - n_years,
    dataset = "Income (City Districts)",
    .groups = 'drop'
  ) %>%
  rename(Gemeindename = KreisLang) %>%
  mutate(Gemeinde_BFS_Nr = NA_integer_)

# 3. Income_kt dataset - check data availability
income_kt_years <- unique(income_kt$INDIKATOR_JAHR)
income_kt_year_range <- range(income_kt_years)

income_kt_coverage <- income_kt %>%
  group_by(BFS_NR, GEBIET_NAME) %>%
  summarise(
    min_year = min(INDIKATOR_JAHR),
    max_year = max(INDIKATOR_JAHR),
    n_years = n_distinct(INDIKATOR_JAHR),
    missing_years = max(income_kt_years) - min(income_kt_years) + 1 - n_years,
    dataset = "Income (Canton)",
    .groups = 'drop'
  ) %>%
  rename(Gemeinde_BFS_Nr = BFS_NR, Gemeindename = GEBIET_NAME)

# Combine all coverage data
all_coverage <- bind_rows(
  ebd_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset),
  income_st_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset),
  income_kt_coverage %>% select(Gemeinde_BFS_Nr, Gemeindename, n_years, min_year, max_year, missing_years, dataset)
)

# # Summary table of available years per dataset
# year_summary <- all_coverage %>%
#   group_by(dataset) %>%
#   summarise(
#     Dataset_Min_Year = min(min_year),
#     Dataset_Max_Year = max(max_year),
#     Year_Range = paste(min(min_year), "-", max(max_year)),
#     Total_Entities = n(),
#     Avg_Years_Available = round(mean(n_years), 1),
#     Entities_With_Missing_Years = sum(missing_years > 0),
#     .groups = "drop"
#   )

# Simple boxplot with jitter - no annotations
p1 <- ggplot(all_coverage, aes(x = dataset, y = n_years, fill = dataset)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3, size = 1) +
  labs(
    title = "Data Availability Comparison Across Datasets",
    x = "Dataset",
    y = "Number of Years Available",
    fill = "Dataset"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# Display plot
print(p1)
```
The datasets employed in this analysis vary in their temporal completeness across the observation period from 1999 to 2023. Among the three primary data sources, only the income data for city districts (Stadt Zurich) provide complete coverage for all geographic units across the entire timeframe, with no missing observations.
The burglary dataset exhibits minimal missingness, with one municipality showing absent data for reasons that could not be determined from the available documentation. The limited scope of this gap suggests negligible impact on the overall analysis.
Income data at the cantonal level (municipal aggregation) demonstrate more substantial incompleteness, with several municipalities missing data for specific years. Table 1 provides a detailed breakdown of missing observations by municipality and year, allowing for transparent assessment of potential limitations in temporal coverage.

```{r echo = FALSE, results = 'asis'}
all_coverage %>%
  filter(missing_years > 0) %>%
  arrange(dataset, n_years) %>%
  select(dataset, Gemeindename, Gemeinde_BFS_Nr, n_years, missing_years, start_year = min_year, end_year = max_year) %>%
  kable(caption = "Municipalities with Incomplete Coverage",
        col.names = c("Dataset", "Municipality", "BFS Nr", "Years Available", 
                      "Missing Years", "Start Year", "End Year"),
        format = "latex",
        longtable = TRUE,
        booktabs = TRUE) %>%
  kable_styling(font_size = 9, latex_options = "scale_down")
```

Further investigation revealed that the missing income data were not random but rather systematic, arising from administrative boundary changes. Between 2015 and 2019, several municipalities in Canton Zurich underwent mergers, resulting in the creation of new administrative units with updated BFS (Federal Statistical Office) identifiers. Specifically:

On 1 January 2019, the former municipalities of Ober-, Unterstammheim, and Waltalingen merged to form the new municipality of Stammheim  
On 1 January 2019, the former municipalities of Hütten and Schönenberg merged into the municipality of Wädenswil  
On 1 January 2018, the former municipality of Hofstetten merged into the municipality of Elgg  
On 1 January 2018, the former municipality of Hirzel merged into the municipality of Horgen  
On 1 January 2016, Kyburg and Illnau-Effretikon merged to form the municipality of Illnau-Effretikon  

These mergers resulted in discontinued BFS identifiers for the former municipalities, with new identifiers assigned to the merged entities. Consequently, income data appeared "missing" for the merged municipalities in pre-merger years, as these records remained associated with the former municipal identifiers.
To address this issue, we implemented a systematic reconciliation procedure. For each merged municipality, we first assessed the completeness of income data under the new identifier. Where gaps existed for pre-merger years, we reconstructed the median income values by averaging data from the constituent former municipalities. This approach ensured temporal continuity in the income variable while maintaining geographic consistency with the current administrative boundaries used in the burglary and spatial datasets.

```{r echo = FALSE, include = FALSE}
# Define merger mapping
merger_mapping <- tribble(
  ~old_BFS_Nr, ~new_BFS_Nr, ~merge_year,
  # Stammheim merger (2019)
  36,          292,          2019,
  42,          292,          2019,
  44,          292,          2019,
  # Wädenswil merger (2019)
  134,         293,          2019,
  140,         293,          2019,
  142,         293,          2019,
  # Elgg merger (2018)
  217,         294,          2018,
  222,         294,          2018,
  # Horgen merger (2018)
  132,         295,          2018,
  133,         295,          2018,
  # Illnau-Effretikon merger (2016)
  174,         296,          2016,
  175,         296,          2016,
  # Bauma merger (2015)
  171,         297,          2015,
  179,         297,          2015
)

all_synthetic <- list()

years <- sort(unique(income_kt$INDIKATOR_JAHR))

for (bfs in unique(merger_mapping$new_BFS_Nr)) {
  
  old_bfs <- merger_mapping %>% 
    filter(new_BFS_Nr == bfs) %>% 
    pull(old_BFS_Nr)
  
  bfs_years <- income_kt %>%
    filter(BFS_NR == bfs) %>%
    pull(INDIKATOR_JAHR) %>%
    unique()
  
  missing_years <- setdiff(years, bfs_years)
  
  if (length(missing_years) > 0) {
    
    synthetic <- income_kt %>% 
      filter(BFS_NR %in% old_bfs,
             INDIKATOR_JAHR %in% missing_years) %>%
      group_by(INDIKATOR_JAHR) %>%
      summarise(
        INCOME_VALUE = mean(INCOME_VALUE, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      mutate(BFS_NR = bfs)
    
    all_synthetic[[as.character(bfs)]] <- synthetic
  }
}

income_old_bfs_all <- bind_rows(all_synthetic) %>%
  left_join(
    income_kt %>%
      select(BFS_NR, GEBIET_NAME) %>%
      distinct(),
    by = "BFS_NR"
  )

# Remove ALL old municipalities
income_kt <- income_kt %>%
  filter(!BFS_NR %in% merger_mapping$old_BFS_Nr)

# Add synthetic rows
income_kt <- income_kt %>%
  bind_rows(income_old_bfs_all) %>%
  arrange(BFS_NR, INDIKATOR_JAHR)
```

## Joining the Datasets

```{r include = TRUE}
# Merge data sets
data <- ebd %>% 
  left_join(income_kt, 
            by = c("Gemeinde_BFS_Nr" = "BFS_NR",
                   "Ausgangsjahr" = "INDIKATOR_JAHR")) %>% 
  left_join(income_st %>% 
              select(KreisLang, StichtagDatJahr, INCOME_VALUE) %>% 
              rename(INCOME_VALUE_ST = INCOME_VALUE),
            by = c("Stadtkreis_Name" = "KreisLang",
                   "Ausgangsjahr" = "StichtagDatJahr")) %>% 
  mutate(INCOME_VALUE = if_else(!is.na(INCOME_VALUE_ST), 
                                INCOME_VALUE_ST, 
                                INCOME_VALUE)) %>% 
  select(-INCOME_VALUE_ST)

# Join geoms of the municipalities
data <- data %>% 
  left_join(ktzh_geom, by = c("Gemeinde_BFS_Nr" = "BFS"))

# Convert data's geometry to MULTIPOLYGON first
data <- data %>%
  mutate(geom = st_cast(geom, "MULTIPOLYGON"))

# Join and replace only the EMPTY geometries
data <- data %>%
  left_join(
    stzh_geom %>%
      select(kname, 
             geom_stzh = geom, 
             distance_to_border_stzh = distance_to_border, 
             distance_to_border_km_stzh = distance_to_border_km),
    by = c("Stadtkreis_Name" = "kname")
  ) %>%
  mutate(
    geom = if_else(st_is_empty(geom) & !is.na(geom_stzh), 
                   geom_stzh, 
                   geom),
    distance_to_border = coalesce(distance_to_border_stzh, distance_to_border),
    distance_to_border_km = coalesce(distance_to_border_km_stzh, distance_to_border_km)
  ) %>%
  select(-geom_stzh, -distance_to_border_stzh, -distance_to_border_km_stzh) %>%
  st_as_sf() %>% 
  mutate(Gemeinde_BFS_Nr = if_else(Gemeindename == "Zürich", 
                                   Stadtkreis_BFS_Nr, 
                                   Gemeinde_BFS_Nr))
```

# Exploratory Data Analysis

## Income Distribution

<!-- ## Municipality Burglary Boxplots -->

<!-- ```{r} -->
<!-- # Aggregate burglaries per municipality (across all years) -->
<!--   burglary_per_municipality <- data %>% -->
<!--     group_by(Gemeinde_BFS_Nr, Gemeindename) %>% -->
<!--     summarise( -->
<!--       Total_Burglaries = sum(Straftaten_total, na.rm = TRUE), -->
<!--       Mean_Burglaries = mean(Straftaten_total, na.rm = TRUE), -->
<!--       .groups = "drop" -->
<!--     ) -->

<!--   # Boxplot of total burglaries per municipality -->
<!--   ggplot(burglary_per_municipality, aes(y = Total_Burglaries)) + -->
<!--     geom_boxplot(fill = "steelblue", alpha = 0.7, outlier.color = "red", outlier.size   = 2) + -->
<!--     labs( -->
<!--       title = "Distribution of Total Burglary Cases per Municipality", -->
<!--       subtitle = "Aggregated across all years (2009-2024)", -->
<!--       y = "Total Burglaries per Municipality", -->
<!--       caption = "Each observation is ONE municipality" -->
<!--     ) + -->
<!--     theme_minimal() + -->
<!--     theme(axis.text.x = element_blank(), -->
<!--           axis.ticks.x = element_blank()) -->

<!-- # Boxplot of average burglaries per municipality -->
<!--   ggplot(burglary_per_municipality, aes(y = Mean_Burglaries)) + -->
<!--     geom_boxplot(fill = "steelblue", alpha = 0.7, outlier.color = "red", outlier.size   = 2) + -->
<!--     labs( -->
<!--       title = "Distribution of Average Annual Burglaries per Municipality", -->
<!--       y = "Average Burglaries per Year", -->
<!--       caption = "Each observation is ONE municipality" -->
<!--     ) + -->
<!--     theme_minimal() + -->
<!--     theme(axis.text.x = element_blank(), -->
<!--           axis.ticks.x = element_blank()) -->
<!-- ``` -->


## Burglary Rates by Municipality

```{r echo = FALSE, fig.show='hold'}
# City outline for map
# Create the outer boundary of Zurich city
city_outline <- data %>%
  filter(!is.na(Stadtkreis_BFS_Nr)) %>%
  st_union()  # Dissolves all districts into one polygon

# Get bounding box of municipalities
bbox <- st_bbox(ktzh_geom)
padding <- 5000  # in map units (meters for Swiss CRS)

# Plot the crime rate across whole data set
ebd_per_gmd <- data %>% 
  group_by(Gemeinde_BFS_Nr) %>% 
  mutate(Total_EBD = sum(Straftaten_total, na.rm = TRUE), 
         Einwohner_avg = mean(Einwohner, na.rm = TRUE),
         EBD_pop_ratio = Total_EBD / Einwohner_avg) %>% 
  summarise(across(c(geom, Einwohner_avg, Total_EBD, EBD_pop_ratio), first),
  .groups = "drop") %>% 
  st_as_sf()

ggplot() +
  geom_sf(data = swiss_borders, fill = NA, color = "black", linewidth = 1) +
  geom_sf(data = ebd_per_gmd, aes(fill = EBD_pop_ratio), color = "white", linewidth = 0.3) +
  geom_sf(data = city_outline, 
          fill = NA, 
          color = "black", 
          size = 0.5) +
  scale_fill_viridis_c(name = "EBD Ratio per Population") +
  coord_sf(xlim = c(bbox["xmin"] - padding, bbox["xmax"] + padding), 
           ylim = c(bbox["ymin"] - padding, bbox["ymax"] + padding)) +
  theme_minimal() +
  labs(title = "Number of Burglaries per Municipality by Population")
```

The city district Kreis 1 seems to be a strong outlier in the data. To have a more balanced output of the burglary rate per municipality and population, this is how the map of the canton of Zurich looks without the outlier:

```{r echo = FALSE}
ggplot() +
  geom_sf(data = swiss_borders, fill = NA, color = "black", linewidth = 1) +
  geom_sf(data = ebd_per_gmd %>% filter(Gemeinde_BFS_Nr != 2610001), aes(fill = EBD_pop_ratio), color = "white", linewidth = 0.3) +
  geom_sf(data = city_outline, 
          fill = NA, 
          color = "black", 
          size = 0.5) +
  scale_fill_viridis_c(name = "EBD Ratio per Population") +
  coord_sf(xlim = c(bbox["xmin"] - padding, bbox["xmax"] + padding), 
           ylim = c(bbox["ymin"] - padding, bbox["ymax"] + padding)) +
  theme_minimal() +
  labs(title = "Number of Burglaries per Municipality by Population (without Kreis 1)")
```

## Correlation Overview

# Modelling

## H1: Income and Burglaries

## H2: National Border Proximity and Burglaries

# Chapter of Choice

?shiny?

# Conclusions

## Key Findings

## Limitations

# Generative AI Reflection
